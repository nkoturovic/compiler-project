/* For more infomation, look at official bison 
 * (c++ parser section) documentation */
%{
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include "../include/driver.hpp"
#include "../include/ast/ast.hpp"
#include "../include/lang/data_types.hpp"
#include "../include/lang/operators.hpp"
#include "../include/structs.hpp"

/* Syntax error function */
void yy::parser::error(const location_type& l, const std::string& msg) {
	driver.error(l, msg);
}
%}

%language "c++"
%locations

%define api.value.type variant
%define api.token.constructor
%define parse.trace

/* Better error messages */
%define parse.error verbose

/* Pass to flex */
%code requires {
class Driver;
using namespace cpl;
}
%param { Driver &driver }

/* Token definitions */
%token
eof_token 0 "end of file"	
print_token "print"          
if_token "if"          
while_token "while"          
int_kw_token "int"          
double_kw_token "double"          
char_kw_token "char"          
crl_lparen_token "{"            
crl_rparen_token "}"            
sqr_lparen_token "["            
sqr_rparen_token "]"            
plus_token "+"    
minus_token "-"   
asterix_token "*"                   
slash_token "/"                   
backslash_token "\\"                   
percent_token "%"                   
lparen_token "("  
rparen_token ")"  
assign_token "="  
eq_token "=="  
lt_token "<"      
gt_token ">"      
leq_token "<="      
geq_token ">="      
shl_token "<<"      
shr_token ">>"      
semicol_token ";" 
dot_token "." 
col_token ":" 
comma_token ","   
backtick_token "`"   
dbl_amp_token "&&"
excl_token "!"
tilde_token "~"
amp_token "&"
dbl_pipe_token "||"
pipe_token "|"

/* No union needed, we are using bison variant */
%token <std::string> id_token "identifier";
%token <int> int_token "Integer literal";
%token <double> double_token "Floating point literal";
%token <char> char_token "Char literal";
%token <std::string> string_token "String literal";

%left "="
%left "&&"
%left "||"

%left "==" "!="

%left "|"
%left "^"
%left "&"

%left "<" "<=" ">" ">="

%left "<<" ">>"

%left "+" "-"
%left "*" "/" "%"

%nonassoc "!" "~"
%nonassoc UMINUS UPLUS
%nonassoc CALL

%type <std::unique_ptr<ast::Statement>> Stmt Sprt_stmt
%type <std::unique_ptr<ast::Expression>> Expr
%type <std::unique_ptr<ast::Literal>> Literal

%%
/* Consider maybe using std::swap instead of std::move everywhere 
 * because there is discussion about potential move problems with 
 * bison variant types */

Program : Block {}


Block : "{" List_of_stmts "}"
      | "{" /* Empty Block */ "}"
      ;


List_of_stmts : List_of_stmts Stmt { }
              | Stmt { }
              ;

Stmt : Sprt_stmt ";" { } /* Stmt that ends with separator  */
     | ";" { } /* Empty statement */ {}
     | Block { }
     ;

Sprt_stmt : Expr { 
            $1->interpret(); 
          }
          | print_token "(" List_of_expr ")" {}
	      ;

Type : Primitive_type
     ;

Primitive_type : "char" | "int" | "double";
           ;

Expr : "(" Expr ")" {}
     | Expr "+" Expr { $$ = std::make_unique<ast::BinOp>(@$, lang::BinOpId::PLUS, std::move($1), std::move($3)); }
     | Expr "-" Expr { $$ = std::make_unique<ast::BinOp>(@$, lang::BinOpId::MINUS, std::move($1), std::move($3)); }
     | Expr "*" Expr { $$ = std::make_unique<ast::BinOp>(@$, lang::BinOpId::MUL, std::move($1), std::move($3)); }
     | Expr "/" Expr { $$ = std::make_unique<ast::BinOp>(@$, lang::BinOpId::DIV, std::move($1), std::move($3)); }
     | Expr "&&" Expr { $$ = std::make_unique<ast::BinOp>(@$, lang::BinOpId::L_AND, std::move($1), std::move($3)); }
     | Expr "||" Expr { $$ = std::make_unique<ast::BinOp>(@$, lang::BinOpId::L_OR, std::move($1), std::move($3)); }
     | Expr "&" Expr { $$ = std::make_unique<ast::BinOp>(@$, lang::BinOpId::B_AND, std::move($1), std::move($3)); }
     | Expr "|" Expr { $$ = std::make_unique<ast::BinOp>(@$, lang::BinOpId::B_OR, std::move($1), std::move($3)); }
     | Expr "^" Expr { $$ = std::make_unique<ast::BinOp>(@$, lang::BinOpId::B_XOR, std::move($1), std::move($3)); }
     | Expr "<" Expr { $$ = std::make_unique<ast::BinOp>(@$, lang::BinOpId::LT, std::move($1), std::move($3)); }
     | Expr ">" Expr { $$ = std::make_unique<ast::BinOp>(@$, lang::BinOpId::GT, std::move($1), std::move($3)); }
     | Expr "<=" Expr { $$ = std::make_unique<ast::BinOp>(@$, lang::BinOpId::LEQ, std::move($1), std::move($3)); }
     | Expr ">=" Expr { $$ = std::make_unique<ast::BinOp>(@$, lang::BinOpId::GEQ, std::move($1), std::move($3)); }
     | Expr "<<" Expr { $$ = std::make_unique<ast::BinOp>(@$, lang::BinOpId::SHL, std::move($1), std::move($3)); }
     | Expr ">>" Expr { $$ = std::make_unique<ast::BinOp>(@$, lang::BinOpId::SHR, std::move($1), std::move($3)); }
     | Expr "==" Expr { $$ = std::make_unique<ast::BinOp>(@$, lang::BinOpId::EQ, std::move($1), std::move($3)); }
     | Expr "!=" Expr { $$ = std::make_unique<ast::BinOp>(@$, lang::BinOpId::NEQ, std::move($1), std::move($3)); }
     | Expr "%" Expr { $$ = std::make_unique<ast::BinOp>(@$, lang::BinOpId::MOD, std::move($1), std::move($3));  }
     | id_token "[" Expr "]" { }
     | "!" Expr { }
     | "~" Expr { }
     | Func_call %prec CALL { }
     | "-" Expr %prec UMINUS { }
     | "+" Expr %prec UPLUS { }
     | id_token { }
     | Literal { $$ = std::move($1); }
     ;

Literal : char_token { $$ = std::make_unique<ast::Literal>(@$, lang::Data(lang::DataType::CHAR, $1)); }
        | int_token { $$ = std::make_unique<ast::Literal>(@$, lang::Data(lang::DataType::INT, $1)); }
        | double_token { $$ = std::make_unique<ast::Literal>(@$, lang::Data(lang::DataType::DOUBLE, $1)); }
        ;


Func_call : id_token "(" Parameters ")" { }

Parameters : List_of_expr { }
           ;

List_of_expr : List_of_expr "," Expr {}
             | Expr {}
             ;

LVal : id_token { }
     | id_token "[" Expr "]" { }
     ;

%%

int main(int argc, char * argv[])
{
	bool read_from_file = false;
	Driver driver;
    Driver::set_active_instance(driver);

	int i;
	for (i = 1; i < argc; i++) {
		if (argv[i] == std::string ("-p")) {
			driver.trace_parsing = true;
		} else if (argv[i] == std::string ("-s")) {
			driver.trace_scanning = true;
		} else {
			read_from_file = true;
		}
	}

	if (read_from_file)
		driver.parse(argv[i-1]);
	else
		driver.parse();

	return 0;
}
